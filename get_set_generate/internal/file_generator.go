package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"go/token"
	"log"
	"path"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/aman-bansal/go_get_set_generator/get_set_generate/internal/models"
)

type Generator struct {
	Setters bool
	Getters bool

	buf        bytes.Buffer
	indent     string
	packageMap map[string]string // map from import path to package structName
}

func (g *Generator) p(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *Generator) in() {
	g.indent += "\t"
}

func (g *Generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[:len(g.indent)-1]
	}
}

func (g *Generator) Generate(file *models.FileInfo) error {
	g.p("// Code generated by getter and setter. DO NOT EDIT.")
	g.p("")

	// Get all required packageNameVsImportPath, and generate unique names for them all.
	imports := file.Imports()
	// Sort keys to make import alias generation predictable
	sorted_paths := make([]string, len(imports), len(imports))
	x := 0
	for importPath := range imports {
		sorted_paths[x] = importPath
		x++
	}
	sort.Strings(sorted_paths)

	g.packageMap = make(map[string]string, len(imports))
	localNames := make(map[string]bool, len(imports))
	for _, pth := range sorted_paths {
		base := sanitize(path.Base(pth))

		// Local names for an imported package can usually be the basename of the import pkgPath.
		// A couple of situations don't permit that, such as duplicate local names
		// (e.g. importing "html/template" and "text/template"), or where the basename is
		// a keyword (e.g. "foo/case").
		// try base0, base1, ...
		pkgName := base
		i := 0
		for localNames[pkgName] || token.Lookup(pkgName).IsKeyword() {
			pkgName = base + strconv.Itoa(i)
			i++
		}

		g.packageMap[pth] = pkgName
		localNames[pkgName] = true
	}

	g.p("package %v", file.PackageName)
	g.p("")
	g.p("import (")
	g.in()
	for pkgPath, pkgName := range g.packageMap {
		if pkgPath != file.ImportPath {
			g.p("%v %q", pkgName, pkgPath)
		}
	}
	for _, pkgPath := range file.DotImports {
		g.p(". %q", pkgPath)
	}
	g.out()
	g.p(")")

	for _, obj := range file.Structs {
		if err := g.GenerateGetterAndSetters(obj, file.ImportPath); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) GenerateGetterAndSetters(obj *models.Struct, currentPackage string) error {
	g.p("")

	for _, field := range obj.Fields {
		receiver := strings.ToLower(obj.Name)[:1]
		if g.Getters {
			g.p("func (%v %v) Get%v() %v {", receiver, obj.Name, field.Name, field.Type.String(g.packageMap, currentPackage))
			g.in()
			g.p("return %v.%v", receiver, field.Name)
			g.out()
			g.p("}")
			g.p("")
		}

		if g.Setters {
			g.p("func (%v *%v) Set%v(val %v) {", receiver, obj.Name, field.Name, field.Type.String(g.packageMap, currentPackage))
			g.in()
			g.p("%v.%v = val", receiver, field.Name)
			g.out()
			g.p("}")
			g.p("")
		}
	}

	return nil
}

func (g *Generator) Output() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated source code: %s\n%s", err, g.buf.String())
	}
	return src
}

// sanitize cleans up a string to make a suitable package structName.
func sanitize(s string) string {
	t := ""
	for _, r := range s {
		if t == "" {
			if unicode.IsLetter(r) || r == '_' {
				t += string(r)
				continue
			}
		} else {
			if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
				t += string(r)
				continue
			}
		}
		t += "_"
	}
	if t == "_" {
		t = "x"
	}
	return t
}
